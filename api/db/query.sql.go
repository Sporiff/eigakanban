// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBoard = `-- name: AddBoard :one
INSERT INTO
    boards (name, description, user_id)
VALUES
    ($1, $2, $3)
RETURNING
    board_id,
    name,
    description,
    created_date
`

type AddBoardParams struct {
	Name        string
	Description pgtype.Text
	UserID      pgtype.Int8
}

type AddBoardRow struct {
	BoardID     pgtype.Int8
	Name        string
	Description pgtype.Text
	CreatedDate pgtype.Timestamptz
}

func (q *Queries) AddBoard(ctx context.Context, arg AddBoardParams) (AddBoardRow, error) {
	row := q.db.QueryRow(ctx, addBoard, arg.Name, arg.Description, arg.UserID)
	var i AddBoardRow
	err := row.Scan(
		&i.BoardID,
		&i.Name,
		&i.Description,
		&i.CreatedDate,
	)
	return i, err
}

const addColumn = `-- name: AddColumn :one
WITH max_position AS (
    SELECT COALESCE(MAX(position), 0) AS max_position
    FROM kbcolumns
    WHERE board_id = $2
)
INSERT INTO kbcolumns (name, board_id, user_id, position)
VALUES
    ($1, $2, $3, (SELECT max_position + 1 FROM max_position))
RETURNING column_id, name, board_id, user_id, position, created_date
`

type AddColumnParams struct {
	Name    string
	BoardID pgtype.Int8
	UserID  pgtype.Int8
}

func (q *Queries) AddColumn(ctx context.Context, arg AddColumnParams) (Kbcolumn, error) {
	row := q.db.QueryRow(ctx, addColumn, arg.Name, arg.BoardID, arg.UserID)
	var i Kbcolumn
	err := row.Scan(
		&i.ColumnID,
		&i.Name,
		&i.BoardID,
		&i.UserID,
		&i.Position,
		&i.CreatedDate,
	)
	return i, err
}

const addColumnAtPosition = `-- name: AddColumnAtPosition :one
WITH shift_columns AS (
    UPDATE kbcolumns
        SET position = position + 1
        WHERE board_id = $2 AND position >= $3
        RETURNING column_id, position
)
INSERT INTO kbcolumns (name, board_id, user_id, position)
VALUES ($1, $2, $3, $3)
RETURNING column_id, name, board_id, user_id, position, created_date
`

type AddColumnAtPositionParams struct {
	Name    string
	BoardID pgtype.Int8
	UserID  pgtype.Int8
}

func (q *Queries) AddColumnAtPosition(ctx context.Context, arg AddColumnAtPositionParams) (Kbcolumn, error) {
	row := q.db.QueryRow(ctx, addColumnAtPosition, arg.Name, arg.BoardID, arg.UserID)
	var i Kbcolumn
	err := row.Scan(
		&i.ColumnID,
		&i.Name,
		&i.BoardID,
		&i.UserID,
		&i.Position,
		&i.CreatedDate,
	)
	return i, err
}

const addColumnItemAtPosition = `-- name: AddColumnItemAtPosition :one
WITH moved_items AS (
    UPDATE column_items
        SET position = position + 1
        WHERE column_id = $1 AND position >= $2
        RETURNING column_item_id, column_id, item_id, position
)
INSERT INTO column_items (column_id, item_id, user_id, position)
VALUES ($1, $2, $3, $2)
RETURNING column_item_id, column_id, item_id, position
`

type AddColumnItemAtPositionParams struct {
	ColumnID pgtype.Int8
	ItemID   pgtype.Int8
	UserID   pgtype.Int8
}

type AddColumnItemAtPositionRow struct {
	ColumnItemID pgtype.Int8
	ColumnID     pgtype.Int8
	ItemID       pgtype.Int8
	Position     pgtype.Int4
}

func (q *Queries) AddColumnItemAtPosition(ctx context.Context, arg AddColumnItemAtPositionParams) (AddColumnItemAtPositionRow, error) {
	row := q.db.QueryRow(ctx, addColumnItemAtPosition, arg.ColumnID, arg.ItemID, arg.UserID)
	var i AddColumnItemAtPositionRow
	err := row.Scan(
		&i.ColumnItemID,
		&i.ColumnID,
		&i.ItemID,
		&i.Position,
	)
	return i, err
}

const addReview = `-- name: AddReview :one
INSERT INTO
    reviews (item_id, user_id, content)
VALUES
    ($1, $2, $3)
RETURNING
    review_id,
    user_id,
    item_id,
    content,
    created_date
`

type AddReviewParams struct {
	ItemID  pgtype.Int8
	UserID  pgtype.Int8
	Content string
}

type AddReviewRow struct {
	ReviewID    pgtype.Int8
	UserID      pgtype.Int8
	ItemID      pgtype.Int8
	Content     string
	CreatedDate pgtype.Timestamptz
}

func (q *Queries) AddReview(ctx context.Context, arg AddReviewParams) (AddReviewRow, error) {
	row := q.db.QueryRow(ctx, addReview, arg.ItemID, arg.UserID, arg.Content)
	var i AddReviewRow
	err := row.Scan(
		&i.ReviewID,
		&i.UserID,
		&i.ItemID,
		&i.Content,
		&i.CreatedDate,
	)
	return i, err
}

const addStatus = `-- name: AddStatus :one
INSERT INTO
    statuses (user_id, label)
VALUES
    ($1, $2)
RETURNING
    status_id,
    user_id,
    label,
    created_date
`

type AddStatusParams struct {
	UserID pgtype.Int8
	Label  pgtype.Text
}

func (q *Queries) AddStatus(ctx context.Context, arg AddStatusParams) (Status, error) {
	row := q.db.QueryRow(ctx, addStatus, arg.UserID, arg.Label)
	var i Status
	err := row.Scan(
		&i.StatusID,
		&i.UserID,
		&i.Label,
		&i.CreatedDate,
	)
	return i, err
}

const addUser = `-- name: AddUser :one
INSERT INTO
    users (username, hashed_password, email, full_name, bio)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING
    user_id,
    username,
    full_name,
    bio,
    created_date
`

type AddUserParams struct {
	Username       string
	HashedPassword string
	Email          string
	FullName       pgtype.Text
	Bio            pgtype.Text
}

type AddUserRow struct {
	UserID      pgtype.Int8
	Username    string
	FullName    pgtype.Text
	Bio         pgtype.Text
	CreatedDate pgtype.Timestamptz
}

func (q *Queries) AddUser(ctx context.Context, arg AddUserParams) (AddUserRow, error) {
	row := q.db.QueryRow(ctx, addUser,
		arg.Username,
		arg.HashedPassword,
		arg.Email,
		arg.FullName,
		arg.Bio,
	)
	var i AddUserRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.FullName,
		&i.Bio,
		&i.CreatedDate,
	)
	return i, err
}

const deleteBoard = `-- name: DeleteBoard :exec
DELETE FROM boards
WHERE
    board_id = $1
`

func (q *Queries) DeleteBoard(ctx context.Context, boardID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteBoard, boardID)
	return err
}

const deleteColumn = `-- name: DeleteColumn :exec
WITH deleted_column AS (
    DELETE FROM kbcolumns as kc
        WHERE kc.column_id = $1
        RETURNING kc.position, kc.board_id
)
UPDATE kbcolumns
SET position = position - 1
WHERE board_id = (SELECT board_id FROM deleted_column)
  AND position > (SELECT position FROM deleted_column)
`

func (q *Queries) DeleteColumn(ctx context.Context, columnID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteColumn, columnID)
	return err
}

const deleteColumnItem = `-- name: DeleteColumnItem :exec
WITH deleted_item AS (
    DELETE FROM column_items as ci
        WHERE ci.column_item_id = $1
        RETURNING ci.position, ci.column_id
)
UPDATE column_items
SET position = position - 1
WHERE column_id = (SELECT di.column_id FROM deleted_item AS di)
  AND position > (SELECT di.position FROM deleted_item AS di)
`

func (q *Queries) DeleteColumnItem(ctx context.Context, columnItemID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteColumnItem, columnItemID)
	return err
}

const deleteReview = `-- name: DeleteReview :exec
DELETE FROM reviews
WHERE
    review_id = $1
`

func (q *Queries) DeleteReview(ctx context.Context, reviewID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteReview, reviewID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE
    user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const getAllBoards = `-- name: GetAllBoards :many
SELECT
    name,
    description
FROM
    boards
ORDER BY
    board_id
LIMIT
    $1
    OFFSET
    $2
`

type GetAllBoardsParams struct {
	Limit  int32
	Offset int32
}

type GetAllBoardsRow struct {
	Name        string
	Description pgtype.Text
}

func (q *Queries) GetAllBoards(ctx context.Context, arg GetAllBoardsParams) ([]GetAllBoardsRow, error) {
	rows, err := q.db.Query(ctx, getAllBoards, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBoardsRow
	for rows.Next() {
		var i GetAllBoardsRow
		if err := rows.Scan(&i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStatuses = `-- name: GetAllStatuses :many
SELECT status_id, user_id, label, created_date FROM statuses
ORDER BY
    created_date
LIMIT
    $1
    OFFSET
    $2
`

type GetAllStatusesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetAllStatuses(ctx context.Context, arg GetAllStatusesParams) ([]Status, error) {
	rows, err := q.db.Query(ctx, getAllStatuses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Status
	for rows.Next() {
		var i Status
		if err := rows.Scan(
			&i.StatusID,
			&i.UserID,
			&i.Label,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT
    username,
    full_name,
    bio
FROM
    users
ORDER BY
    user_id
LIMIT
    $1
    OFFSET
    $2
`

type GetAllUsersParams struct {
	Limit  int32
	Offset int32
}

type GetAllUsersRow struct {
	Username string
	FullName pgtype.Text
	Bio      pgtype.Text
}

func (q *Queries) GetAllUsers(ctx context.Context, arg GetAllUsersParams) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(&i.Username, &i.FullName, &i.Bio); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBoardById = `-- name: GetBoardById :one
SELECT
    name,
    description
FROM
    boards
WHERE
    board_id = $1
LIMIT
    1
`

type GetBoardByIdRow struct {
	Name        string
	Description pgtype.Text
}

func (q *Queries) GetBoardById(ctx context.Context, boardID pgtype.Int8) (GetBoardByIdRow, error) {
	row := q.db.QueryRow(ctx, getBoardById, boardID)
	var i GetBoardByIdRow
	err := row.Scan(&i.Name, &i.Description)
	return i, err
}

const getBoardsForUser = `-- name: GetBoardsForUser :many
SELECT
    name,
    description
FROM
    boards
WHERE
    user_id = $1
ORDER BY
    board_id
LIMIT
    $2
    OFFSET
    $3
`

type GetBoardsForUserParams struct {
	UserID pgtype.Int8
	Limit  int32
	Offset int32
}

type GetBoardsForUserRow struct {
	Name        string
	Description pgtype.Text
}

func (q *Queries) GetBoardsForUser(ctx context.Context, arg GetBoardsForUserParams) ([]GetBoardsForUserRow, error) {
	rows, err := q.db.Query(ctx, getBoardsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBoardsForUserRow
	for rows.Next() {
		var i GetBoardsForUserRow
		if err := rows.Scan(&i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumn = `-- name: GetColumn :one
SELECT column_id, name, board_id, user_id, position, created_date FROM kbcolumns
WHERE column_id = $1
`

func (q *Queries) GetColumn(ctx context.Context, columnID pgtype.Int8) (Kbcolumn, error) {
	row := q.db.QueryRow(ctx, getColumn, columnID)
	var i Kbcolumn
	err := row.Scan(
		&i.ColumnID,
		&i.Name,
		&i.BoardID,
		&i.UserID,
		&i.Position,
		&i.CreatedDate,
	)
	return i, err
}

const getColumns = `-- name: GetColumns :many
SELECT column_id, name, board_id, user_id, position, created_date FROM kbcolumns
ORDER BY
    created_date
LIMIT
    $1
    OFFSET
    $2
`

type GetColumnsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetColumns(ctx context.Context, arg GetColumnsParams) ([]Kbcolumn, error) {
	rows, err := q.db.Query(ctx, getColumns, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Kbcolumn
	for rows.Next() {
		var i Kbcolumn
		if err := rows.Scan(
			&i.ColumnID,
			&i.Name,
			&i.BoardID,
			&i.UserID,
			&i.Position,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnsForBoard = `-- name: GetColumnsForBoard :many
SELECT column_id, name, board_id, user_id, position, created_date FROM kbcolumns
WHERE board_id = $1
ORDER BY
    position
LIMIT
    $2
    OFFSET
    $3
`

type GetColumnsForBoardParams struct {
	BoardID pgtype.Int8
	Limit   int32
	Offset  int32
}

func (q *Queries) GetColumnsForBoard(ctx context.Context, arg GetColumnsForBoardParams) ([]Kbcolumn, error) {
	rows, err := q.db.Query(ctx, getColumnsForBoard, arg.BoardID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Kbcolumn
	for rows.Next() {
		var i Kbcolumn
		if err := rows.Scan(
			&i.ColumnID,
			&i.Name,
			&i.BoardID,
			&i.UserID,
			&i.Position,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnsForUser = `-- name: GetColumnsForUser :many
SELECT column_id, name, board_id, user_id, position, created_date FROM kbcolumns
WHERE user_id = $1
ORDER BY
    created_date
LIMIT
    $2
    OFFSET
    $3
`

type GetColumnsForUserParams struct {
	UserID pgtype.Int8
	Limit  int32
	Offset int32
}

func (q *Queries) GetColumnsForUser(ctx context.Context, arg GetColumnsForUserParams) ([]Kbcolumn, error) {
	rows, err := q.db.Query(ctx, getColumnsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Kbcolumn
	for rows.Next() {
		var i Kbcolumn
		if err := rows.Scan(
			&i.ColumnID,
			&i.Name,
			&i.BoardID,
			&i.UserID,
			&i.Position,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReview = `-- name: GetReview :one
SELECT
    review_id, content, user_id, item_id, created_date
FROM
    reviews
WHERE
    review_id = $1
LIMIT
    1
`

func (q *Queries) GetReview(ctx context.Context, reviewID pgtype.Int8) (Review, error) {
	row := q.db.QueryRow(ctx, getReview, reviewID)
	var i Review
	err := row.Scan(
		&i.ReviewID,
		&i.Content,
		&i.UserID,
		&i.ItemID,
		&i.CreatedDate,
	)
	return i, err
}

const getReviewsForItem = `-- name: GetReviewsForItem :many
SELECT
    review_id, content, user_id, item_id, created_date
FROM
    reviews
WHERE
    item_id = $1
ORDER BY
    created_date
LIMIT
    $2
    OFFSET
    $3
`

type GetReviewsForItemParams struct {
	ItemID pgtype.Int8
	Limit  int32
	Offset int32
}

func (q *Queries) GetReviewsForItem(ctx context.Context, arg GetReviewsForItemParams) ([]Review, error) {
	rows, err := q.db.Query(ctx, getReviewsForItem, arg.ItemID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ReviewID,
			&i.Content,
			&i.UserID,
			&i.ItemID,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsForUser = `-- name: GetReviewsForUser :many
SELECT
    review_id, content, user_id, item_id, created_date
FROM
    reviews
WHERE
    user_id = $1
ORDER BY
    created_date
LIMIT
    $2
    OFFSET
    $3
`

type GetReviewsForUserParams struct {
	UserID pgtype.Int8
	Limit  int32
	Offset int32
}

func (q *Queries) GetReviewsForUser(ctx context.Context, arg GetReviewsForUserParams) ([]Review, error) {
	rows, err := q.db.Query(ctx, getReviewsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ReviewID,
			&i.Content,
			&i.UserID,
			&i.ItemID,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatus = `-- name: GetStatus :one
SELECT status_id, user_id, label, created_date FROM statuses
WHERE
    status_id = $1
LIMIT
    1
`

func (q *Queries) GetStatus(ctx context.Context, statusID pgtype.Int8) (Status, error) {
	row := q.db.QueryRow(ctx, getStatus, statusID)
	var i Status
	err := row.Scan(
		&i.StatusID,
		&i.UserID,
		&i.Label,
		&i.CreatedDate,
	)
	return i, err
}

const getStatusesForUser = `-- name: GetStatusesForUser :many
SELECT status_id, user_id, label, created_date FROM statuses
WHERE
    user_id = $1
ORDER BY
    created_date
LIMIT
    $2
OFFSET
    $3
`

type GetStatusesForUserParams struct {
	UserID pgtype.Int8
	Limit  int32
	Offset int32
}

func (q *Queries) GetStatusesForUser(ctx context.Context, arg GetStatusesForUserParams) ([]Status, error) {
	rows, err := q.db.Query(ctx, getStatusesForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Status
	for rows.Next() {
		var i Status
		if err := rows.Scan(
			&i.StatusID,
			&i.UserID,
			&i.Label,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT
    username,
    full_name,
    bio
FROM
    users
WHERE
    user_id = $1
LIMIT
    1
`

type GetUserByIdRow struct {
	Username string
	FullName pgtype.Text
	Bio      pgtype.Text
}

func (q *Queries) GetUserById(ctx context.Context, userID pgtype.Int8) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, userID)
	var i GetUserByIdRow
	err := row.Scan(&i.Username, &i.FullName, &i.Bio)
	return i, err
}

const moveColumn = `-- name: MoveColumn :one
WITH neighbors AS (
    SELECT column_id, position
    FROM kbcolumns
    WHERE board_id = $2 AND column_id != $1
    ORDER BY position
),
     updated_positions AS (
         UPDATE kbcolumns
             SET position = CASE
                                WHEN kbcolumns.column_id = $1 THEN $2  -- New position for the moved column
                                WHEN kbcolumns.column_id = $3 THEN $4  -- Update neighbor's position
                                ELSE kbcolumns.position
                 END
             WHERE kbcolumns.board_id = $5
             RETURNING kbcolumns.column_id, kbcolumns.position
     )
UPDATE kbcolumns
SET position = kbcolumns.position + CASE
                                        WHEN kbcolumns.column_id = $1 THEN -1  -- Move column left
                                        WHEN kbcolumns.column_id = $2 THEN +1  -- Move column right
                                        ELSE 0
    END
WHERE kbcolumns.column_id IN (SELECT updated_positions.column_id FROM updated_positions)
RETURNING kbcolumns.column_id, kbcolumns.position
`

type MoveColumnParams struct {
	ColumnID   pgtype.Int8
	ColumnID_2 pgtype.Int8
	ColumnID_3 pgtype.Int8
	Position   int32
	BoardID    pgtype.Int8
}

type MoveColumnRow struct {
	ColumnID pgtype.Int8
	Position int32
}

func (q *Queries) MoveColumn(ctx context.Context, arg MoveColumnParams) (MoveColumnRow, error) {
	row := q.db.QueryRow(ctx, moveColumn,
		arg.ColumnID,
		arg.ColumnID_2,
		arg.ColumnID_3,
		arg.Position,
		arg.BoardID,
	)
	var i MoveColumnRow
	err := row.Scan(&i.ColumnID, &i.Position)
	return i, err
}

const moveColumnItemDown = `-- name: MoveColumnItemDown :one
WITH current_position AS (
    SELECT position
    FROM column_items AS ci
    WHERE ci.column_item_id = $1
),
     items_to_shift AS (
         SELECT ci.column_item_id, ci.position
         FROM column_items AS ci
         WHERE ci.column_id = $2
           AND ci.position = (SELECT cp.position FROM current_position AS cp) + 1
     )
UPDATE column_items AS ci
SET position = CASE
                   WHEN ci.column_item_id = $1 THEN ci.position + 1
                   WHEN ci.column_item_id IN (SELECT its.column_item_id FROM items_to_shift AS its) THEN ci.position - 1
                   ELSE ci.position
    END
WHERE ci.column_item_id IN (SELECT its.column_item_id FROM items_to_shift AS its)
   OR ci.column_item_id = $1
RETURNING ci.column_item_id, ci.column_id, ci.item_id, ci.position
`

type MoveColumnItemDownParams struct {
	ColumnItemID pgtype.Int8
	ColumnID     pgtype.Int8
}

type MoveColumnItemDownRow struct {
	ColumnItemID pgtype.Int8
	ColumnID     pgtype.Int8
	ItemID       pgtype.Int8
	Position     pgtype.Int4
}

func (q *Queries) MoveColumnItemDown(ctx context.Context, arg MoveColumnItemDownParams) (MoveColumnItemDownRow, error) {
	row := q.db.QueryRow(ctx, moveColumnItemDown, arg.ColumnItemID, arg.ColumnID)
	var i MoveColumnItemDownRow
	err := row.Scan(
		&i.ColumnItemID,
		&i.ColumnID,
		&i.ItemID,
		&i.Position,
	)
	return i, err
}

const moveColumnItemUp = `-- name: MoveColumnItemUp :one
WITH current_position AS (
    SELECT position
    FROM column_items AS ci
    WHERE ci.column_item_id = $1
),
     items_to_shift AS (
         SELECT ci.column_item_id, ci.position
         FROM column_items AS ci
         WHERE ci.column_id = $2
           AND ci.position = (SELECT cp.position FROM current_position AS cp) - 1
     )
UPDATE column_items AS ci
SET position = CASE
                   WHEN ci.column_item_id = $1 THEN ci.position - 1
                   WHEN ci.column_item_id IN (SELECT its.column_item_id FROM items_to_shift AS its) THEN ci.position + 1
                   ELSE ci.position
    END
WHERE ci.column_item_id IN (SELECT its.column_item_id FROM items_to_shift AS its)
   OR ci.column_item_id = $1
RETURNING ci.column_item_id, ci.column_id, ci.item_id, ci.position
`

type MoveColumnItemUpParams struct {
	ColumnItemID pgtype.Int8
	ColumnID     pgtype.Int8
}

type MoveColumnItemUpRow struct {
	ColumnItemID pgtype.Int8
	ColumnID     pgtype.Int8
	ItemID       pgtype.Int8
	Position     pgtype.Int4
}

func (q *Queries) MoveColumnItemUp(ctx context.Context, arg MoveColumnItemUpParams) (MoveColumnItemUpRow, error) {
	row := q.db.QueryRow(ctx, moveColumnItemUp, arg.ColumnItemID, arg.ColumnID)
	var i MoveColumnItemUpRow
	err := row.Scan(
		&i.ColumnItemID,
		&i.ColumnID,
		&i.ItemID,
		&i.Position,
	)
	return i, err
}

const moveItemToColumn = `-- name: MoveItemToColumn :one
WITH moved_items AS (
    UPDATE column_items AS ci
        SET position = position + 1
        WHERE ci.column_id = $2 AND ci.position >= (SELECT ci2.position FROM column_items AS ci2 WHERE ci2.column_item_id = $1)
        RETURNING ci.column_item_id, ci.column_id, ci.item_id, ci.position
)
UPDATE column_items AS ci
SET column_id = $2
WHERE ci.column_item_id = $1
RETURNING ci.column_item_id, ci.column_id, ci.item_id, ci.position
`

type MoveItemToColumnParams struct {
	ColumnItemID pgtype.Int8
	ColumnID     pgtype.Int8
}

type MoveItemToColumnRow struct {
	ColumnItemID pgtype.Int8
	ColumnID     pgtype.Int8
	ItemID       pgtype.Int8
	Position     pgtype.Int4
}

func (q *Queries) MoveItemToColumn(ctx context.Context, arg MoveItemToColumnParams) (MoveItemToColumnRow, error) {
	row := q.db.QueryRow(ctx, moveItemToColumn, arg.ColumnItemID, arg.ColumnID)
	var i MoveItemToColumnRow
	err := row.Scan(
		&i.ColumnItemID,
		&i.ColumnID,
		&i.ItemID,
		&i.Position,
	)
	return i, err
}

const updateBoard = `-- name: UpdateBoard :one
UPDATE boards
SET
    name = $2,
    description = $3
WHERE
    board_id = $1
RETURNING
    board_id,
    name,
    description
`

type UpdateBoardParams struct {
	BoardID     pgtype.Int8
	Name        string
	Description pgtype.Text
}

type UpdateBoardRow struct {
	BoardID     pgtype.Int8
	Name        string
	Description pgtype.Text
}

func (q *Queries) UpdateBoard(ctx context.Context, arg UpdateBoardParams) (UpdateBoardRow, error) {
	row := q.db.QueryRow(ctx, updateBoard, arg.BoardID, arg.Name, arg.Description)
	var i UpdateBoardRow
	err := row.Scan(&i.BoardID, &i.Name, &i.Description)
	return i, err
}

const updateColumn = `-- name: UpdateColumn :one
UPDATE kbcolumns
SET
    name = $2
WHERE
    column_id = $1
RETURNING
    column_id, name, board_id, user_id, position, created_date
`

type UpdateColumnParams struct {
	ColumnID pgtype.Int8
	Name     string
}

func (q *Queries) UpdateColumn(ctx context.Context, arg UpdateColumnParams) (Kbcolumn, error) {
	row := q.db.QueryRow(ctx, updateColumn, arg.ColumnID, arg.Name)
	var i Kbcolumn
	err := row.Scan(
		&i.ColumnID,
		&i.Name,
		&i.BoardID,
		&i.UserID,
		&i.Position,
		&i.CreatedDate,
	)
	return i, err
}

const updateReview = `-- name: UpdateReview :one
UPDATE reviews
SET
    content = $2
WHERE
    review_id = $1
RETURNING
    review_id,
    item_id,
    content
`

type UpdateReviewParams struct {
	ReviewID pgtype.Int8
	Content  string
}

type UpdateReviewRow struct {
	ReviewID pgtype.Int8
	ItemID   pgtype.Int8
	Content  string
}

func (q *Queries) UpdateReview(ctx context.Context, arg UpdateReviewParams) (UpdateReviewRow, error) {
	row := q.db.QueryRow(ctx, updateReview, arg.ReviewID, arg.Content)
	var i UpdateReviewRow
	err := row.Scan(&i.ReviewID, &i.ItemID, &i.Content)
	return i, err
}

const updateUserDetails = `-- name: UpdateUserDetails :one
UPDATE users
SET
    username = $2,
    full_name = $3,
    bio = $4
WHERE
    user_id = $1
RETURNING
    username,
    full_name,
    bio
`

type UpdateUserDetailsParams struct {
	UserID   pgtype.Int8
	Username string
	FullName pgtype.Text
	Bio      pgtype.Text
}

type UpdateUserDetailsRow struct {
	Username string
	FullName pgtype.Text
	Bio      pgtype.Text
}

func (q *Queries) UpdateUserDetails(ctx context.Context, arg UpdateUserDetailsParams) (UpdateUserDetailsRow, error) {
	row := q.db.QueryRow(ctx, updateUserDetails,
		arg.UserID,
		arg.Username,
		arg.FullName,
		arg.Bio,
	)
	var i UpdateUserDetailsRow
	err := row.Scan(&i.Username, &i.FullName, &i.Bio)
	return i, err
}
