// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: list_item_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addItemToListAtPosition = `-- name: AddItemToListAtPosition :one
WITH new_item AS (
    INSERT INTO list_items (list_id, item_id, position, prev_item_id, next_item_id, status_id)
        VALUES (
                   (SELECT list_id FROM lists WHERE lists.uuid = $1),
                   (SELECT item_id FROM items WHERE items.uuid = $2),
                   $3,
                   (SELECT list_item_id FROM list_items WHERE list_id = (SELECT list_id FROM lists WHERE lists.uuid = $1) AND status_id = (SELECT status_id FROM statuses WHERE statuses.uuid = $4) AND list_items.position = $5),
                   (SELECT list_item_id FROM list_items WHERE list_id = (SELECT list_id FROM lists WHERE lists.uuid = $1) AND status_id = (SELECT status_id FROM statuses WHERE statuses.uuid = $4) AND list_items.position = $6),
                   (SELECT status_id FROM statuses WHERE uuid = $4)
               )
        RETURNING list_item_id, list_id, position, prev_item_id, next_item_id, status_id
),
     update_prev_item AS (
         UPDATE list_items
             SET next_item_id = new_item.list_item_id
             FROM new_item
             WHERE list_items.list_item_id = new_item.prev_item_id
                 AND new_item.prev_item_id IS NOT NULL
     ),
     update_next_item AS (
         UPDATE list_items
             SET prev_item_id = new_item.list_item_id
             FROM new_item
             WHERE list_items.list_item_id = new_item.next_item_id
                 AND new_item.next_item_id IS NOT NULL
     )
SELECT list_items.uuid, list_items.position
FROM list_items
         JOIN items ON list_items.item_id = items.item_id
WHERE list_items.list_item_id = (SELECT list_item_id FROM new_item)
`

type AddItemToListAtPositionParams struct {
	ListUuid     pgtype.UUID `json:"list_uuid"`
	ItemUuid     pgtype.UUID `json:"item_uuid"`
	NewPosition  int32       `json:"new_position"`
	StatusUuid   pgtype.UUID `json:"status_uuid"`
	PrevPosition int32       `json:"prev_position"`
	NextPosition int32       `json:"next_position"`
}

type AddItemToListAtPositionRow struct {
	Uuid     pgtype.UUID `json:"uuid"`
	Position int32       `json:"position"`
}

// Arguments: list_uuid, item_uuid, new_position, status_uuid
func (q *Queries) AddItemToListAtPosition(ctx context.Context, arg AddItemToListAtPositionParams) (AddItemToListAtPositionRow, error) {
	row := q.db.QueryRow(ctx, addItemToListAtPosition,
		arg.ListUuid,
		arg.ItemUuid,
		arg.NewPosition,
		arg.StatusUuid,
		arg.PrevPosition,
		arg.NextPosition,
	)
	var i AddItemToListAtPositionRow
	err := row.Scan(&i.Uuid, &i.Position)
	return i, err
}

const deleteItemFromList = `-- name: DeleteItemFromList :exec
WITH deleted_item AS (
    DELETE FROM list_items
        WHERE list_items.uuid = $1
        RETURNING list_item_id, prev_item_id, next_item_id, status_id
),
     update_prev_item AS (
         UPDATE list_items
             SET next_item_id = deleted_item.next_item_id
             FROM deleted_item
             WHERE list_items.list_item_id = deleted_item.prev_item_id
                 AND deleted_item.prev_item_id IS NOT NULL
                 AND list_items.status_id = deleted_item.status_id
     ),
     update_next_item AS (
         UPDATE list_items
             SET prev_item_id = deleted_item.prev_item_id
             FROM deleted_item
             WHERE list_items.list_item_id = deleted_item.next_item_id
                 AND deleted_item.next_item_id IS NOT NULL
                 AND list_items.status_id = deleted_item.status_id
     )
SELECT 1
`

// Arguments: list_item_uuid
func (q *Queries) DeleteItemFromList(ctx context.Context, listItemUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteItemFromList, listItemUuid)
	return err
}

const getAllListItems = `-- name: GetAllListItems :many
SELECT li.uuid AS list_item_uuid, l.uuid AS list_uuid, i.uuid AS item_uuid, s.label, li.position
FROM list_items li
JOIN lists l ON l.list_id = li.list_id
JOIN items i ON i.item_id = li.item_id
JOIN statuses s ON s.status_id = li.status_id
ORDER BY
    li.position
LIMIT
    $2
    OFFSET
    $1
`

type GetAllListItemsParams struct {
	Page     int32 `json:"page"`
	PageSize int32 `json:"page_size"`
}

type GetAllListItemsRow struct {
	ListItemUuid pgtype.UUID `json:"list_item_uuid"`
	ListUuid     pgtype.UUID `json:"list_uuid"`
	ItemUuid     pgtype.UUID `json:"item_uuid"`
	Label        pgtype.Text `json:"label"`
	Position     int32       `json:"position"`
}

func (q *Queries) GetAllListItems(ctx context.Context, arg GetAllListItemsParams) ([]GetAllListItemsRow, error) {
	rows, err := q.db.Query(ctx, getAllListItems, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllListItemsRow
	for rows.Next() {
		var i GetAllListItemsRow
		if err := rows.Scan(
			&i.ListItemUuid,
			&i.ListUuid,
			&i.ItemUuid,
			&i.Label,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllListItemsCount = `-- name: GetAllListItemsCount :one
SELECT COUNT(*)
FROM list_items
`

func (q *Queries) GetAllListItemsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAllListItemsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getListItemsByListUuid = `-- name: GetListItemsByListUuid :many
SELECT li.uuid AS list_item_uuid, l.uuid AS list_uuid, i.uuid AS item_uuid, s.label, li.position
FROM list_items li
JOIN lists l ON l.list_id = li.list_id
JOIN items i ON i.item_id = li.item_id
JOIN statuses s ON s.status_id = li.status_id
WHERE
    li.uuid = $1
ORDER BY
    li.position
LIMIT
    $3
    OFFSET
    $2
`

type GetListItemsByListUuidParams struct {
	ListUuid pgtype.UUID `json:"list_uuid"`
	Page     int32       `json:"page"`
	PageSize int32       `json:"page_size"`
}

type GetListItemsByListUuidRow struct {
	ListItemUuid pgtype.UUID `json:"list_item_uuid"`
	ListUuid     pgtype.UUID `json:"list_uuid"`
	ItemUuid     pgtype.UUID `json:"item_uuid"`
	Label        pgtype.Text `json:"label"`
	Position     int32       `json:"position"`
}

func (q *Queries) GetListItemsByListUuid(ctx context.Context, arg GetListItemsByListUuidParams) ([]GetListItemsByListUuidRow, error) {
	rows, err := q.db.Query(ctx, getListItemsByListUuid, arg.ListUuid, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListItemsByListUuidRow
	for rows.Next() {
		var i GetListItemsByListUuidRow
		if err := rows.Scan(
			&i.ListItemUuid,
			&i.ListUuid,
			&i.ItemUuid,
			&i.Label,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListItemsCountForList = `-- name: GetListItemsCountForList :one
SELECT COUNT(*)
FROM list_items li
WHERE li.list_id = (SELECT l.list_id FROM lists l WHERE l.uuid = $1)
`

func (q *Queries) GetListItemsCountForList(ctx context.Context, listUuid pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getListItemsCountForList, listUuid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const moveItemInList = `-- name: MoveItemInList :one
WITH current_item AS (
    SELECT list_item_id, prev_item_id, next_item_id, position, list_id, status_id
    FROM list_items
    WHERE list_items.uuid = $1
),
     updated_positions AS (
         UPDATE list_items
             SET position = position + CASE
                                           WHEN list_items.position >= $2 THEN 1
                                           ELSE -1
                 END
             WHERE list_id = (SELECT list_id FROM current_item)
                 AND status_id = (SELECT status_id FROM statuses WHERE statuses.uuid = $3)
                 AND position BETWEEN LEAST($2, (SELECT position FROM current_item))
                       AND GREATEST($2, (SELECT position FROM current_item))
             RETURNING list_item_id, position
     ),
     update_current_item AS (
         UPDATE list_items
             SET
                 position = $2,
                 prev_item_id = (SELECT list_item_id FROM list_items WHERE list_id = (SELECT list_id FROM current_item) AND status_id = (SELECT status_id FROM statuses WHERE uuid = $3) AND list_items.position = $4),
                 next_item_id = (SELECT list_item_id FROM list_items WHERE list_id = (SELECT list_id FROM current_item) AND status_id = (SELECT status_id FROM statuses WHERE uuid = $3) AND list_items.position = $5),
                 status_id = (SELECT status_id FROM statuses WHERE uuid = $3)
             WHERE list_item_id = (SELECT list_item_id FROM current_item)
             RETURNING uuid, position, prev_item_id, next_item_id
     )
SELECT uuid, position, prev_item_id, next_item_id
FROM update_current_item
`

type MoveItemInListParams struct {
	ListItemUuid pgtype.UUID `json:"list_item_uuid"`
	NewPosition  int32       `json:"new_position"`
	StatusUuid   pgtype.UUID `json:"status_uuid"`
	PrevPosition int32       `json:"prev_position"`
	NextPosition int32       `json:"next_position"`
}

type MoveItemInListRow struct {
	Uuid       pgtype.UUID `json:"uuid"`
	Position   int32       `json:"position"`
	PrevItemID pgtype.Int8 `json:"prev_item_id"`
	NextItemID pgtype.Int8 `json:"next_item_id"`
}

// Arguments: list_item_uuid, new_position, status_uuid
func (q *Queries) MoveItemInList(ctx context.Context, arg MoveItemInListParams) (MoveItemInListRow, error) {
	row := q.db.QueryRow(ctx, moveItemInList,
		arg.ListItemUuid,
		arg.NewPosition,
		arg.StatusUuid,
		arg.PrevPosition,
		arg.NextPosition,
	)
	var i MoveItemInListRow
	err := row.Scan(
		&i.Uuid,
		&i.Position,
		&i.PrevItemID,
		&i.NextItemID,
	)
	return i, err
}
