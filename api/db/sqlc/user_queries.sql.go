// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUser = `-- name: AddUser :one
INSERT INTO
    users (username, hashed_password, email, full_name, bio)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING
    user_id,
    username,
    full_name,
    bio,
    created_date
`

type AddUserParams struct {
	Username       string      `json:"username"`
	HashedPassword string      `json:"hashed_password"`
	Email          string      `json:"email"`
	FullName       pgtype.Text `json:"full_name"`
	Bio            pgtype.Text `json:"bio"`
}

type AddUserRow struct {
	UserID      pgtype.Int8        `json:"user_id"`
	Username    string             `json:"username"`
	FullName    pgtype.Text        `json:"full_name"`
	Bio         pgtype.Text        `json:"bio"`
	CreatedDate pgtype.Timestamptz `json:"created_date"`
}

func (q *Queries) AddUser(ctx context.Context, arg AddUserParams) (AddUserRow, error) {
	row := q.db.QueryRow(ctx, addUser,
		arg.Username,
		arg.HashedPassword,
		arg.Email,
		arg.FullName,
		arg.Bio,
	)
	var i AddUserRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.FullName,
		&i.Bio,
		&i.CreatedDate,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE
    user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT
    username,
    full_name,
    bio
FROM
    users
ORDER BY
    user_id
LIMIT
    $1
    OFFSET
    $2
`

type GetAllUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllUsersRow struct {
	Username string      `json:"username"`
	FullName pgtype.Text `json:"full_name"`
	Bio      pgtype.Text `json:"bio"`
}

func (q *Queries) GetAllUsers(ctx context.Context, arg GetAllUsersParams) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(&i.Username, &i.FullName, &i.Bio); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT
    username,
    full_name,
    bio
FROM
    users
WHERE
    user_id = $1
LIMIT
    1
`

type GetUserByIdRow struct {
	Username string      `json:"username"`
	FullName pgtype.Text `json:"full_name"`
	Bio      pgtype.Text `json:"bio"`
}

func (q *Queries) GetUserById(ctx context.Context, userID pgtype.Int8) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, userID)
	var i GetUserByIdRow
	err := row.Scan(&i.Username, &i.FullName, &i.Bio)
	return i, err
}

const updateUserDetails = `-- name: UpdateUserDetails :one
UPDATE users
SET
    username = $2,
    full_name = $3,
    bio = $4
WHERE
    user_id = $1
RETURNING
    username,
    full_name,
    bio
`

type UpdateUserDetailsParams struct {
	UserID   pgtype.Int8 `json:"user_id"`
	Username string      `json:"username"`
	FullName pgtype.Text `json:"full_name"`
	Bio      pgtype.Text `json:"bio"`
}

type UpdateUserDetailsRow struct {
	Username string      `json:"username"`
	FullName pgtype.Text `json:"full_name"`
	Bio      pgtype.Text `json:"bio"`
}

func (q *Queries) UpdateUserDetails(ctx context.Context, arg UpdateUserDetailsParams) (UpdateUserDetailsRow, error) {
	row := q.db.QueryRow(ctx, updateUserDetails,
		arg.UserID,
		arg.Username,
		arg.FullName,
		arg.Bio,
	)
	var i UpdateUserDetailsRow
	err := row.Scan(&i.Username, &i.FullName, &i.Bio)
	return i, err
}
