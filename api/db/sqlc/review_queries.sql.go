// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: review_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addReview = `-- name: AddReview :one
INSERT INTO
    reviews (item_id, user_id, content)
VALUES
    (
        (
            SELECT
                item_id
            FROM
                items
            WHERE
                items.uuid = $1
        ),
        (
            SELECT
                user_id
            FROM
                users
            WHERE
                users.uuid = $2
        ),
        $3
    )
RETURNING
    uuid,
    content,
    created_date
`

type AddReviewParams struct {
	ItemUuid pgtype.UUID `json:"item_uuid"`
	UserUuid pgtype.UUID `json:"user_uuid"`
	Content  string      `json:"content"`
}

type AddReviewRow struct {
	Uuid        pgtype.UUID        `json:"uuid"`
	Content     string             `json:"content"`
	CreatedDate pgtype.Timestamptz `json:"created_date"`
}

func (q *Queries) AddReview(ctx context.Context, arg AddReviewParams) (AddReviewRow, error) {
	row := q.db.QueryRow(ctx, addReview, arg.ItemUuid, arg.UserUuid, arg.Content)
	var i AddReviewRow
	err := row.Scan(&i.Uuid, &i.Content, &i.CreatedDate)
	return i, err
}

const deleteReview = `-- name: DeleteReview :exec
DELETE FROM reviews
WHERE
    uuid = $1
`

func (q *Queries) DeleteReview(ctx context.Context, reviewUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteReview, reviewUuid)
	return err
}

const getReview = `-- name: GetReview :one
SELECT
    uuid,
    content,
    created_date
FROM
    reviews
WHERE
    uuid = $1
LIMIT
    1
`

type GetReviewRow struct {
	Uuid        pgtype.UUID        `json:"uuid"`
	Content     string             `json:"content"`
	CreatedDate pgtype.Timestamptz `json:"created_date"`
}

func (q *Queries) GetReview(ctx context.Context, reviewUuid pgtype.UUID) (GetReviewRow, error) {
	row := q.db.QueryRow(ctx, getReview, reviewUuid)
	var i GetReviewRow
	err := row.Scan(&i.Uuid, &i.Content, &i.CreatedDate)
	return i, err
}

const getReviewsForItem = `-- name: GetReviewsForItem :many
SELECT
    r.uuid,
    r.content,
    r.created_date
FROM
    reviews r
        JOIN items i ON i.item_id = r.item_id
WHERE
    i.uuid = $1
ORDER BY
    r.created_date
LIMIT
    $3
    OFFSET
    $2
`

type GetReviewsForItemParams struct {
	ItemUuid pgtype.UUID `json:"item_uuid"`
	Page     int32       `json:"page"`
	PageSize int32       `json:"page_size"`
}

type GetReviewsForItemRow struct {
	Uuid        pgtype.UUID        `json:"uuid"`
	Content     string             `json:"content"`
	CreatedDate pgtype.Timestamptz `json:"created_date"`
}

func (q *Queries) GetReviewsForItem(ctx context.Context, arg GetReviewsForItemParams) ([]GetReviewsForItemRow, error) {
	rows, err := q.db.Query(ctx, getReviewsForItem, arg.ItemUuid, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsForItemRow
	for rows.Next() {
		var i GetReviewsForItemRow
		if err := rows.Scan(&i.Uuid, &i.Content, &i.CreatedDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsForUser = `-- name: GetReviewsForUser :many
SELECT
    r.uuid,
    r.content,
    r.created_date
FROM
    reviews r
        JOIN users u ON u.user_id = r.user_id
WHERE
    u.uuid = $1
ORDER BY
    r.created_date
LIMIT
    $3
    OFFSET
    $2
`

type GetReviewsForUserParams struct {
	UserUuid pgtype.UUID `json:"user_uuid"`
	Page     int32       `json:"page"`
	PageSize int32       `json:"page_size"`
}

type GetReviewsForUserRow struct {
	Uuid        pgtype.UUID        `json:"uuid"`
	Content     string             `json:"content"`
	CreatedDate pgtype.Timestamptz `json:"created_date"`
}

func (q *Queries) GetReviewsForUser(ctx context.Context, arg GetReviewsForUserParams) ([]GetReviewsForUserRow, error) {
	rows, err := q.db.Query(ctx, getReviewsForUser, arg.UserUuid, arg.Page, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsForUserRow
	for rows.Next() {
		var i GetReviewsForUserRow
		if err := rows.Scan(&i.Uuid, &i.Content, &i.CreatedDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReview = `-- name: UpdateReview :one
UPDATE reviews
SET
    content = $1
WHERE
    uuid = $2
RETURNING
    uuid,
    content
`

type UpdateReviewParams struct {
	Content    string      `json:"content"`
	ReviewUuid pgtype.UUID `json:"review_uuid"`
}

type UpdateReviewRow struct {
	Uuid    pgtype.UUID `json:"uuid"`
	Content string      `json:"content"`
}

func (q *Queries) UpdateReview(ctx context.Context, arg UpdateReviewParams) (UpdateReviewRow, error) {
	row := q.db.QueryRow(ctx, updateReview, arg.Content, arg.ReviewUuid)
	var i UpdateReviewRow
	err := row.Scan(&i.Uuid, &i.Content)
	return i, err
}
