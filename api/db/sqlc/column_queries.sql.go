// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: column_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addColumn = `-- name: AddColumn :one
WITH max_position AS (
    SELECT COALESCE(MAX(position), 0) AS max_position
    FROM kbcolumns
    WHERE board_id = $2
)
INSERT INTO kbcolumns (name, board_id, user_id, position)
VALUES
    ($1, $2, $3, (SELECT max_position + 1 FROM max_position))
RETURNING column_id, name, board_id, user_id, position, created_date
`

type AddColumnParams struct {
	Name    string      `json:"name"`
	BoardID pgtype.Int8 `json:"board_id"`
	UserID  pgtype.Int8 `json:"user_id"`
}

func (q *Queries) AddColumn(ctx context.Context, arg AddColumnParams) (Kbcolumn, error) {
	row := q.db.QueryRow(ctx, addColumn, arg.Name, arg.BoardID, arg.UserID)
	var i Kbcolumn
	err := row.Scan(
		&i.ColumnID,
		&i.Name,
		&i.BoardID,
		&i.UserID,
		&i.Position,
		&i.CreatedDate,
	)
	return i, err
}

const addColumnAtPosition = `-- name: AddColumnAtPosition :one
WITH shift_columns AS (
    UPDATE kbcolumns
        SET position = position + 1
        WHERE board_id = $2 AND position >= $3
        RETURNING column_id, position
)
INSERT INTO kbcolumns (name, board_id, user_id, position)
VALUES ($1, $2, $3, $3)
RETURNING column_id, name, board_id, user_id, position, created_date
`

type AddColumnAtPositionParams struct {
	Name    string      `json:"name"`
	BoardID pgtype.Int8 `json:"board_id"`
	UserID  pgtype.Int8 `json:"user_id"`
}

func (q *Queries) AddColumnAtPosition(ctx context.Context, arg AddColumnAtPositionParams) (Kbcolumn, error) {
	row := q.db.QueryRow(ctx, addColumnAtPosition, arg.Name, arg.BoardID, arg.UserID)
	var i Kbcolumn
	err := row.Scan(
		&i.ColumnID,
		&i.Name,
		&i.BoardID,
		&i.UserID,
		&i.Position,
		&i.CreatedDate,
	)
	return i, err
}

const deleteColumn = `-- name: DeleteColumn :exec
WITH deleted_column AS (
    DELETE FROM kbcolumns as kc
        WHERE kc.column_id = $1
        RETURNING kc.position, kc.board_id
)
UPDATE kbcolumns
SET position = position - 1
WHERE board_id = (SELECT board_id FROM deleted_column)
  AND position > (SELECT position FROM deleted_column)
`

func (q *Queries) DeleteColumn(ctx context.Context, columnID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteColumn, columnID)
	return err
}

const getColumn = `-- name: GetColumn :one
SELECT column_id, name, board_id, user_id, position, created_date FROM kbcolumns
WHERE column_id = $1
`

func (q *Queries) GetColumn(ctx context.Context, columnID pgtype.Int8) (Kbcolumn, error) {
	row := q.db.QueryRow(ctx, getColumn, columnID)
	var i Kbcolumn
	err := row.Scan(
		&i.ColumnID,
		&i.Name,
		&i.BoardID,
		&i.UserID,
		&i.Position,
		&i.CreatedDate,
	)
	return i, err
}

const getColumns = `-- name: GetColumns :many
SELECT column_id, name, board_id, user_id, position, created_date FROM kbcolumns
ORDER BY
    created_date
LIMIT
    $1
    OFFSET
    $2
`

type GetColumnsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetColumns(ctx context.Context, arg GetColumnsParams) ([]Kbcolumn, error) {
	rows, err := q.db.Query(ctx, getColumns, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Kbcolumn
	for rows.Next() {
		var i Kbcolumn
		if err := rows.Scan(
			&i.ColumnID,
			&i.Name,
			&i.BoardID,
			&i.UserID,
			&i.Position,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnsForBoard = `-- name: GetColumnsForBoard :many
SELECT column_id, name, board_id, user_id, position, created_date FROM kbcolumns
WHERE board_id = $1
ORDER BY
    position
LIMIT
    $2
    OFFSET
    $3
`

type GetColumnsForBoardParams struct {
	BoardID pgtype.Int8 `json:"board_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) GetColumnsForBoard(ctx context.Context, arg GetColumnsForBoardParams) ([]Kbcolumn, error) {
	rows, err := q.db.Query(ctx, getColumnsForBoard, arg.BoardID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Kbcolumn
	for rows.Next() {
		var i Kbcolumn
		if err := rows.Scan(
			&i.ColumnID,
			&i.Name,
			&i.BoardID,
			&i.UserID,
			&i.Position,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getColumnsForUser = `-- name: GetColumnsForUser :many
SELECT column_id, name, board_id, user_id, position, created_date FROM kbcolumns
WHERE user_id = $1
ORDER BY
    created_date
LIMIT
    $2
    OFFSET
    $3
`

type GetColumnsForUserParams struct {
	UserID pgtype.Int8 `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetColumnsForUser(ctx context.Context, arg GetColumnsForUserParams) ([]Kbcolumn, error) {
	rows, err := q.db.Query(ctx, getColumnsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Kbcolumn
	for rows.Next() {
		var i Kbcolumn
		if err := rows.Scan(
			&i.ColumnID,
			&i.Name,
			&i.BoardID,
			&i.UserID,
			&i.Position,
			&i.CreatedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveColumn = `-- name: MoveColumn :one
WITH neighbors AS (
    SELECT column_id, position
    FROM kbcolumns
    WHERE board_id = $2 AND column_id != $1
    ORDER BY position
),
     updated_positions AS (
         UPDATE kbcolumns
             SET position = CASE
                                WHEN kbcolumns.column_id = $1 THEN $2  -- New position for the moved column
                                WHEN kbcolumns.column_id = $3 THEN $4  -- Update neighbor's position
                                ELSE kbcolumns.position
                 END
             WHERE kbcolumns.board_id = $5
             RETURNING kbcolumns.column_id, kbcolumns.position
     )
UPDATE kbcolumns
SET position = kbcolumns.position + CASE
                                        WHEN kbcolumns.column_id = $1 THEN -1  -- Move column left
                                        WHEN kbcolumns.column_id = $2 THEN +1  -- Move column right
                                        ELSE 0
    END
WHERE kbcolumns.column_id IN (SELECT updated_positions.column_id FROM updated_positions)
RETURNING kbcolumns.column_id, kbcolumns.position
`

type MoveColumnParams struct {
	ColumnID   pgtype.Int8 `json:"column_id"`
	ColumnID_2 pgtype.Int8 `json:"column_id_2"`
	ColumnID_3 pgtype.Int8 `json:"column_id_3"`
	Position   int32       `json:"position"`
	BoardID    pgtype.Int8 `json:"board_id"`
}

type MoveColumnRow struct {
	ColumnID pgtype.Int8 `json:"column_id"`
	Position int32       `json:"position"`
}

func (q *Queries) MoveColumn(ctx context.Context, arg MoveColumnParams) (MoveColumnRow, error) {
	row := q.db.QueryRow(ctx, moveColumn,
		arg.ColumnID,
		arg.ColumnID_2,
		arg.ColumnID_3,
		arg.Position,
		arg.BoardID,
	)
	var i MoveColumnRow
	err := row.Scan(&i.ColumnID, &i.Position)
	return i, err
}

const updateColumn = `-- name: UpdateColumn :one
UPDATE kbcolumns
SET
    name = $2
WHERE
    column_id = $1
RETURNING
    column_id, name, board_id, user_id, position, created_date
`

type UpdateColumnParams struct {
	ColumnID pgtype.Int8 `json:"column_id"`
	Name     string      `json:"name"`
}

func (q *Queries) UpdateColumn(ctx context.Context, arg UpdateColumnParams) (Kbcolumn, error) {
	row := q.db.QueryRow(ctx, updateColumn, arg.ColumnID, arg.Name)
	var i Kbcolumn
	err := row.Scan(
		&i.ColumnID,
		&i.Name,
		&i.BoardID,
		&i.UserID,
		&i.Position,
		&i.CreatedDate,
	)
	return i, err
}
