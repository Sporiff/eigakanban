// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: board_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBoard = `-- name: AddBoard :one
INSERT INTO
    boards (name, description, user_id)
VALUES
    ($1, $2, $3)
RETURNING
    board_id,
    name,
    description,
    created_date
`

type AddBoardParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	UserID      pgtype.Int8 `json:"user_id"`
}

type AddBoardRow struct {
	BoardID     pgtype.Int8        `json:"board_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	CreatedDate pgtype.Timestamptz `json:"created_date"`
}

func (q *Queries) AddBoard(ctx context.Context, arg AddBoardParams) (AddBoardRow, error) {
	row := q.db.QueryRow(ctx, addBoard, arg.Name, arg.Description, arg.UserID)
	var i AddBoardRow
	err := row.Scan(
		&i.BoardID,
		&i.Name,
		&i.Description,
		&i.CreatedDate,
	)
	return i, err
}

const deleteBoard = `-- name: DeleteBoard :exec
DELETE FROM boards
WHERE
    board_id = $1
`

func (q *Queries) DeleteBoard(ctx context.Context, boardID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteBoard, boardID)
	return err
}

const getAllBoards = `-- name: GetAllBoards :many
SELECT
    name,
    description
FROM
    boards
ORDER BY
    board_id
LIMIT
    $1
    OFFSET
    $2
`

type GetAllBoardsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllBoardsRow struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) GetAllBoards(ctx context.Context, arg GetAllBoardsParams) ([]GetAllBoardsRow, error) {
	rows, err := q.db.Query(ctx, getAllBoards, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBoardsRow
	for rows.Next() {
		var i GetAllBoardsRow
		if err := rows.Scan(&i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBoardById = `-- name: GetBoardById :one
SELECT
    name,
    description
FROM
    boards
WHERE
    board_id = $1
LIMIT
    1
`

type GetBoardByIdRow struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) GetBoardById(ctx context.Context, boardID pgtype.Int8) (GetBoardByIdRow, error) {
	row := q.db.QueryRow(ctx, getBoardById, boardID)
	var i GetBoardByIdRow
	err := row.Scan(&i.Name, &i.Description)
	return i, err
}

const getBoardsForUser = `-- name: GetBoardsForUser :many
SELECT
    name,
    description
FROM
    boards
WHERE
    user_id = $1
ORDER BY
    board_id
LIMIT
    $2
    OFFSET
    $3
`

type GetBoardsForUserParams struct {
	UserID pgtype.Int8 `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetBoardsForUserRow struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) GetBoardsForUser(ctx context.Context, arg GetBoardsForUserParams) ([]GetBoardsForUserRow, error) {
	rows, err := q.db.Query(ctx, getBoardsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBoardsForUserRow
	for rows.Next() {
		var i GetBoardsForUserRow
		if err := rows.Scan(&i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBoard = `-- name: UpdateBoard :one
UPDATE boards
SET
    name = $2,
    description = $3
WHERE
    board_id = $1
RETURNING
    board_id,
    name,
    description
`

type UpdateBoardParams struct {
	BoardID     pgtype.Int8 `json:"board_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

type UpdateBoardRow struct {
	BoardID     pgtype.Int8 `json:"board_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateBoard(ctx context.Context, arg UpdateBoardParams) (UpdateBoardRow, error) {
	row := q.db.QueryRow(ctx, updateBoard, arg.BoardID, arg.Name, arg.Description)
	var i UpdateBoardRow
	err := row.Scan(&i.BoardID, &i.Name, &i.Description)
	return i, err
}
